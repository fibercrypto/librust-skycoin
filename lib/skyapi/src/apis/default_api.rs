/*
 * Skycoin REST API.
 *
 * Skycoin is a next-generation cryptocurrency.
 *
 * The version of the OpenAPI document: 0.26.0
 * Contact: contact@skycoin.net
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct DefaultApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> DefaultApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> DefaultApiClient<C> {
        DefaultApiClient {
            configuration: configuration,
        }
    }
}

pub trait DefaultApi {
    fn join(&self, seqs: Vec<i32>) -> String;
    fn address_count(&self, ) -> Box<Future<Item = ::models::InlineResponse200, Error = Error<serde_json::Value>>>;
    fn address_uxouts(&self, address: &str) -> Box<Future<Item = Vec<serde_json::Value>, Error = Error<serde_json::Value>>>;
    fn api_v1_rawtx_get(&self, ) -> Box<Future<Item = String, Error = Error<serde_json::Value>>>;
    fn api_v2_metrics_get(&self, ) -> Box<Future<Item = String, Error = Error<serde_json::Value>>>;
    fn balance_get(&self, addrs: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn balance_post(&self, addrs: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn block(&self, hash: &str, seq: i32) -> Box<Future<Item = Vec<::models::BlockSchema>, Error = Error<serde_json::Value>>>;
    fn blockchain_metadata(&self, ) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn blockchain_progress(&self, ) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn blocks(&self, start: i32, end: i32, seq: Vec<i32>) -> Box<Future<Item = ::models::InlineResponse2001, Error = Error<serde_json::Value>>>;
    fn coin_supply(&self, ) -> Box<Future<Item = ::models::InlineResponse2002, Error = Error<serde_json::Value>>>;
    fn csrf(&self, ) -> Box<Future<Item = ::models::InlineResponse2003, Error = Error<serde_json::Value>>>;
    fn data_delete(&self, _type: &str, key: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn data_get(&self, _type: &str, key: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn data_post(&self, _type: &str, key: &str, val: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn default_connections(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn health(&self, ) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn last_blocks(&self, num: i32) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn network_connection(&self, addr: &str) -> Box<Future<Item = ::models::NetworkConnectionSchema, Error = Error<serde_json::Value>>>;
    fn network_connections(&self, states: &str, direction: &str) -> Box<Future<Item = ::models::InlineResponse2004, Error = Error<serde_json::Value>>>;
    fn network_connections_disconnect(&self, id: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn network_connections_exchange(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn network_connections_trust(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn outputs_get(&self, address: Vec<String>, hash: Vec<String>) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn outputs_post(&self, address: &str, hash: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn pending_txs(&self, ) -> Box<Future<Item = Vec<::models::InlineResponse20010>, Error = Error<serde_json::Value>>>;
    fn resend_unconfirmed_txns(&self, ) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn richlist(&self, include_distribution: bool, n: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn transaction(&self, txid: &str) -> Box<Future<Item = ::models::Transaction, Error = Error<serde_json::Value>>>;
    fn transaction_inject(&self, rawtx: &str) -> Box<Future<Item = String, Error = Error<serde_json::Value>>>;
    fn transaction_post(&self, transaction_v2_params_address: ::models::TransactionV2ParamsAddress) -> Box<Future<Item = ::models::InlineResponse2008, Error = Error<serde_json::Value>>>;
    fn transaction_post_unspent(&self, transaction_v2_params_unspent: ::models::TransactionV2ParamsUnspent) -> Box<Future<Item = ::models::InlineResponse2008, Error = Error<serde_json::Value>>>;
    fn transaction_raw(&self, txid: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn transaction_verify(&self, transaction_verify_request: ::models::TransactionVerifyRequest) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn transactions_get(&self, addrs: &str, confirmed: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn transactions_post(&self, addrs: &str, confirmed: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn uxout(&self, uxid: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn verify_address(&self, address: serde_json::Value) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn version(&self, ) -> Box<Future<Item = ::models::InlineResponse2005, Error = Error<serde_json::Value>>>;
    fn wallet(&self, id: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_balance(&self, id: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_create(&self, seed: &str, label: &str, scan: i32, encrypt: bool, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_decrypt(&self, id: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_encrypt(&self, id: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_folder(&self, addr: &str) -> Box<Future<Item = ::models::InlineResponse2007, Error = Error<serde_json::Value>>>;
    fn wallet_new_address(&self, id: &str, num: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_new_seed(&self, entropy: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_recover(&self, id: &str, seed: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_seed(&self, id: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_seed_verify(&self, seed: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_transaction(&self, wallet_transaction_request: ::models::WalletTransactionRequest) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>>;
    fn wallet_transaction_sign(&self, wallet_transaction_sign_request: ::models::WalletTransactionSignRequest) -> Box<Future<Item = ::models::InlineResponse2009, Error = Error<serde_json::Value>>>;
    fn wallet_transactions(&self, id: &str) -> Box<Future<Item = ::models::InlineResponse2006, Error = Error<serde_json::Value>>>;
    fn wallet_unload(&self, id: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn wallet_update(&self, id: &str, label: &str) -> Box<Future<Item = String, Error = Error<serde_json::Value>>>;
    fn wallets(&self, ) -> Box<Future<Item = Vec<serde_json::Value>, Error = Error<serde_json::Value>>>;
}


impl<C: hyper::client::Connect>DefaultApi for DefaultApiClient<C> {
    fn address_count(&self, ) -> Box<Future<Item = ::models::InlineResponse200, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/addresscount".to_string())
            .execute(self.configuration.borrow())
    }

    fn address_uxouts(&self, address: &str) -> Box<Future<Item = Vec<serde_json::Value>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/address_uxouts".to_string())
            .with_query_param("address".to_string(), address.to_string())
            .execute(self.configuration.borrow())
    }

    fn api_v1_rawtx_get(&self, ) -> Box<Future<Item = String, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/rawtx".to_string())
            .execute(self.configuration.borrow())
    }

    fn api_v2_metrics_get(&self, ) -> Box<Future<Item = String, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v2/metrics".to_string())
            .execute(self.configuration.borrow())
    }

    fn balance_get(&self, addrs: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/balance".to_string())
            .with_query_param("addrs".to_string(), addrs.to_string())
            .execute(self.configuration.borrow())
    }

    fn balance_post(&self, addrs: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/balance".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("addrs".to_string(), addrs.to_string())
            .execute(self.configuration.borrow())
    }

    fn block(&self, hash: &str, seq: i32) -> Box<Future<Item = Vec<::models::BlockSchema>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/block".to_string())
            .with_query_param("hash".to_string(), hash.to_string())
            .with_query_param("seq".to_string(), seq.to_string())
            .execute(self.configuration.borrow())
    }

    fn blockchain_metadata(&self, ) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/blockchain/metadata".to_string())
            .execute(self.configuration.borrow())
    }

    fn blockchain_progress(&self, ) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/blockchain/progress".to_string())
            .execute(self.configuration.borrow())
    }

    fn join(&self, seqs: Vec<i32>) -> String {
        let mut result: String = "".parse().unwrap();
        let len = seqs.len();
        for i in seqs {
            result.push_str(&*i.to_string());
            if i as usize == len-1 {
                break;
            }
            result.push_str(",");
        }
        return result;
    }

    fn blocks(&self, start: i32, end: i32, seq: Vec<i32>) -> Box<Future<Item = ::models::InlineResponse2001, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/blocks".to_string())
            .with_query_param("start".to_string(), start.to_string())
            .with_query_param("end".to_string(), end.to_string())
            .with_query_param("seqs".to_string(), self.join(seq))
            .execute(self.configuration.borrow())
    }

    fn coin_supply(&self, ) -> Box<Future<Item = ::models::InlineResponse2002, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/coinSupply".to_string())
            .execute(self.configuration.borrow())
    }

    fn csrf(&self, ) -> Box<Future<Item = ::models::InlineResponse2003, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/csrf".to_string())
            .execute(self.configuration.borrow())
    }

    fn data_delete(&self, _type: &str, key: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Delete, "/api/v2/data".to_string())
            .with_header_param("type".to_string(), _type.to_string())
            .with_header_param("key".to_string(), key.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn data_get(&self, _type: &str, key: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v2/data".to_string())
            .with_header_param("type".to_string(), _type.to_string())
            .with_header_param("key".to_string(), key.to_string())
            .execute(self.configuration.borrow())
    }

    fn data_post(&self, _type: &str, key: &str, val: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/data".to_string())
            .with_header_param("type".to_string(), _type.to_string())
            .with_header_param("key".to_string(), key.to_string())
            .with_header_param("val".to_string(), val.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn default_connections(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/defaultConnections".to_string())
            .execute(self.configuration.borrow())
    }

    fn health(&self, ) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/health".to_string())
            .execute(self.configuration.borrow())
    }

    fn last_blocks(&self, num: i32) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/last_blocks".to_string())
            .with_query_param("num".to_string(), num.to_string())
            .execute(self.configuration.borrow())
    }

    fn network_connection(&self, addr: &str) -> Box<Future<Item = ::models::NetworkConnectionSchema, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/connection".to_string())
            .with_query_param("addr".to_string(), addr.to_string())
            .execute(self.configuration.borrow())
    }

    fn network_connections(&self, states: &str, direction: &str) -> Box<Future<Item = ::models::InlineResponse2004, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/connections".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("states".to_string(), states.to_string())
            .with_query_param("direction".to_string(), direction.to_string())
            .execute(self.configuration.borrow())
    }

    fn network_connections_disconnect(&self, id: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/network/connection/disconnect".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("id".to_string(), id.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn network_connections_exchange(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/connections/exchange".to_string())
            .execute(self.configuration.borrow())
    }

    fn network_connections_trust(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/connections/trust".to_string())
            .execute(self.configuration.borrow())
    }

    fn outputs_get(&self, address: Vec<String>, hash: Vec<String>) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/outputs".to_string())
            .with_query_param("address".to_string(), address.join(",").to_string())
            .with_query_param("hash".to_string(), hash.join(",").to_string())
            .execute(self.configuration.borrow())
    }

    fn outputs_post(&self, address: &str, hash: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/outputs".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("address".to_string(), address.to_string())
            .with_query_param("hash".to_string(), hash.to_string())
            .execute(self.configuration.borrow())
    }

    fn pending_txs(&self, ) -> Box<Future<Item = Vec<::models::InlineResponse20010>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/pendingTxs".to_string())
            .execute(self.configuration.borrow())
    }

    fn resend_unconfirmed_txns(&self, ) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/resendUnconfirmedTxns".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .execute(self.configuration.borrow())
    }

    fn richlist(&self, include_distribution: bool, n: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/richlist".to_string())
            .with_query_param("include-distribution".to_string(), include_distribution.to_string())
            .with_query_param("n".to_string(), n.to_string())
            .execute(self.configuration.borrow())
    }

    fn transaction(&self, txid: &str) -> Box<Future<Item = ::models::Transaction, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/transaction".to_string())
            .with_query_param("txid".to_string(), txid.to_string())
            .execute(self.configuration.borrow())
    }

    fn transaction_inject(&self, rawtx: &str) -> Box<Future<Item = String, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/injectTransaction".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("rawtx".to_string(), rawtx.to_string())
            .execute(self.configuration.borrow())
    }

    fn transaction_post(&self, transaction_v2_params_address: ::models::TransactionV2ParamsAddress) -> Box<Future<Item = ::models::InlineResponse2008, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/transaction".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_body_param(transaction_v2_params_address)
            .execute(self.configuration.borrow())
    }

    fn transaction_post_unspent(&self, transaction_v2_params_unspent: ::models::TransactionV2ParamsUnspent) -> Box<Future<Item = ::models::InlineResponse2008, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/transaction/unspent".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_body_param(transaction_v2_params_unspent)
            .execute(self.configuration.borrow())
    }

    fn transaction_raw(&self, txid: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v2/transaction/raw".to_string())
            .with_query_param("txid".to_string(), txid.to_string())
            .execute(self.configuration.borrow())
    }

    fn transaction_verify(&self, transaction_verify_request: ::models::TransactionVerifyRequest) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/transaction/verify".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_body_param(transaction_verify_request)
            .execute(self.configuration.borrow())
    }

    fn transactions_get(&self, addrs: &str, confirmed: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/transactions".to_string())
            .with_query_param("addrs".to_string(), addrs.to_string())
            .with_query_param("confirmed".to_string(), confirmed.to_string())
            .execute(self.configuration.borrow())
    }

    fn transactions_post(&self, addrs: &str, confirmed: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/transactions".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("addrs".to_string(), addrs.to_string())
            .with_query_param("confirmed".to_string(), confirmed.to_string())
            .execute(self.configuration.borrow())
    }

    fn uxout(&self, uxid: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/uxout".to_string())
            .with_query_param("uxid".to_string(), uxid.to_string())
            .execute(self.configuration.borrow())
    }

    fn verify_address(&self, address: serde_json::Value) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/address/verify".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("address".to_string(), address.to_string())
            .execute(self.configuration.borrow())
    }

    fn version(&self, ) -> Box<Future<Item = ::models::InlineResponse2005, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/version".to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet(&self, id: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallet".to_string())
            .with_query_param("id".to_string(), id.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_balance(&self, id: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallet/balance".to_string())
            .with_query_param("id".to_string(), id.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_create(&self, seed: &str, label: &str, scan: i32, encrypt: bool, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/create".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("seed".to_string(), seed.to_string())
            .with_header_param("label".to_string(), label.to_string())
            .with_header_param("scan".to_string(), scan.to_string())
            .with_header_param("encrypt".to_string(), encrypt.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_decrypt(&self, id: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/decrypt".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_encrypt(&self, id: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/encrypt".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_folder(&self, addr: &str) -> Box<Future<Item = ::models::InlineResponse2007, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallets/folderName".to_string())
            .with_query_param("addr".to_string(), addr.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_new_address(&self, id: &str, num: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/newAddress".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("id".to_string(), id.to_string())
            .with_query_param("num".to_string(), num.to_string())
            .with_query_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_new_seed(&self, entropy: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallet/newSeed".to_string())
            .with_query_param("entropy".to_string(), entropy.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_recover(&self, id: &str, seed: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/wallet/recover".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("seed".to_string(), seed.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_seed(&self, id: &str, password: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/seed".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("id".to_string(), id.to_string())
            .with_query_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_seed_verify(&self, seed: &str) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/wallet/seed/verify".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("seed".to_string(), seed.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_transaction(&self, wallet_transaction_request: ::models::WalletTransactionRequest) -> Box<Future<Item = serde_json::Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/transaction".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_body_param(wallet_transaction_request)
            .execute(self.configuration.borrow())
    }

    fn wallet_transaction_sign(&self, wallet_transaction_sign_request: ::models::WalletTransactionSignRequest) -> Box<Future<Item = ::models::InlineResponse2009, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/wallet/transaction/sign".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_body_param(wallet_transaction_sign_request)
            .execute(self.configuration.borrow())
    }

    fn wallet_transactions(&self, id: &str) -> Box<Future<Item = ::models::InlineResponse2006, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallet/transactions".to_string())
            .with_query_param("id".to_string(), id.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_unload(&self, id: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/unload".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("id".to_string(), id.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn wallet_update(&self, id: &str, label: &str) -> Box<Future<Item = String, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/update".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("label".to_string(), label.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallets(&self, ) -> Box<Future<Item = Vec<serde_json::Value>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallets".to_string())
            .execute(self.configuration.borrow())
    }

}
