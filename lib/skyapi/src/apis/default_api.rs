/*
 * Skycoin REST API.
 *
 * Skycoin is a next-generation cryptocurrency.
 *
 * OpenAPI spec version: 0.25.1
 * Contact: contact@skycoin.net
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct DefaultApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> DefaultApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> DefaultApiClient<C> {
        DefaultApiClient {
            configuration: configuration,
        }
    }
}

pub trait DefaultApi {
    fn address_count(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn address_uxouts(&self, address: &str) -> Box<Future<Item = Vec<::models::InlineResponse200>, Error = Error<serde_json::Value>>>;
    fn balance_get(&self, addrs: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn balance_post(&self, addrs: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn block(&self, hash: &str, seq: i32) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn blockchain_metadata(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn blockchain_progress(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn blocks_get(&self, start: i32, end: i32, seqs: Vec<i32>) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn blocks_post(&self, start: i32, end: i32, seqs: Vec<i32>) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn coin_supply(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn csrf(&self, ) -> Box<Future<Item = ::models::InlineResponse2001, Error = Error<serde_json::Value>>>;
    fn default_connections(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn explorer_address(&self, address: &str) -> Box<Future<Item = Vec<::models::InlineResponse2002>, Error = Error<serde_json::Value>>>;
    fn health(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn last_blocks(&self, num: i32) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn network_connection(&self, addr: &str) -> Box<Future<Item = ::models::InlineResponse2003, Error = Error<serde_json::Value>>>;
    fn network_connections(&self, states: &str, direction: &str) -> Box<Future<Item = Vec<::models::InlineResponse2003>, Error = Error<serde_json::Value>>>;
    fn network_connections_disconnect(&self, id: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn network_connections_exchange(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn network_connections_trust(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn outputs_get(&self, address: Vec<String>, hash: Vec<String>) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn outputs_post(&self, address: &str, hash: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn pending_txs(&self, ) -> Box<Future<Item = Vec<::models::InlineResponse2004>, Error = Error<serde_json::Value>>>;
    fn resend_unconfirmed_txns(&self, ) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn richlist(&self, include_distribution: bool, n: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn transaction(&self, txid: &str, encoded: bool) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn transaction_inject(&self, rawtx: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn transaction_raw(&self, txid: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn transaction_verify(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn transactions_get(&self, addrs: &str, confirmed: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn transactions_post(&self, addrs: &str, confirmed: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn uxout(&self, uxid: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn verify_address(&self, address: &str) -> Box<Future<Item = ::models::InlineResponse2007, Error = Error<serde_json::Value>>>;
    fn version(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet(&self, id: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_balance(&self, id: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_create(&self, seed: &str, label: &str, scan: i32, encrypt: bool, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_decrypt(&self, id: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_encrypt(&self, id: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_folder(&self, addr: &str) -> Box<Future<Item = ::models::InlineResponse2006, Error = Error<serde_json::Value>>>;
    fn wallet_new_address(&self, id: &str, num: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_new_seed(&self, entropy: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_recover(&self, id: &str, seed: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_seed(&self, id: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_seed_verify(&self, seed: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_spent(&self, id: &str, dst: &str, coins: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_transaction(&self, body: ::models::InlineObject) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_transactions(&self, id: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>>;
    fn wallet_unload(&self, id: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn wallet_update(&self, id: &str, label: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn wallets(&self, ) -> Box<Future<Item = Vec<::models::InlineResponse2005>, Error = Error<serde_json::Value>>>;
}


impl<C: hyper::client::Connect>DefaultApi for DefaultApiClient<C> {
    fn address_count(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/addresscount".to_string())
            .execute(self.configuration.borrow())
    }

    fn address_uxouts(&self, address: &str) -> Box<Future<Item = Vec<::models::InlineResponse200>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/address_uxouts".to_string())
            .with_query_param("address".to_string(), address.to_string())
            .execute(self.configuration.borrow())
    }

    fn balance_get(&self, addrs: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/balance".to_string())
            .with_query_param("addrs".to_string(), addrs.to_string())
            .execute(self.configuration.borrow())
    }

    fn balance_post(&self, addrs: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/balance".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("addrs".to_string(), addrs.to_string())
            .execute(self.configuration.borrow())
    }

    fn block(&self, hash: &str, seq: i32) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/block".to_string())
            .with_query_param("hash".to_string(), hash.to_string())
            .with_query_param("seq".to_string(), seq.to_string())
            .execute(self.configuration.borrow())
    }

    fn blockchain_metadata(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/blockchain/metadata".to_string())
            .execute(self.configuration.borrow())
    }

    fn blockchain_progress(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/blockchain/progress".to_string())
            .execute(self.configuration.borrow())
    }

    fn blocks_get(&self, start: i32, end: i32, seqs: Vec<i32>) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/blocks".to_string())
            .with_query_param("start".to_string(), start.to_string())
            .with_query_param("end".to_string(), end.to_string())
            .with_query_param("seqs".to_string(), seqs.join(",").to_string())
            .execute(self.configuration.borrow())
    }

    fn blocks_post(&self, start: i32, end: i32, seqs: Vec<i32>) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/blocks".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("start".to_string(), start.to_string())
            .with_query_param("end".to_string(), end.to_string())
            .with_query_param("seqs".to_string(), seqs.join(",").to_string())
            .execute(self.configuration.borrow())
    }

    fn coin_supply(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/coinSupply".to_string())
            .execute(self.configuration.borrow())
    }

    fn csrf(&self, ) -> Box<Future<Item = ::models::InlineResponse2001, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/csrf".to_string())
            .execute(self.configuration.borrow())
    }

    fn default_connections(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/defaultConnections".to_string())
            .execute(self.configuration.borrow())
    }

    fn explorer_address(&self, address: &str) -> Box<Future<Item = Vec<::models::InlineResponse2002>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/explorer/address".to_string())
            .with_query_param("address".to_string(), address.to_string())
            .execute(self.configuration.borrow())
    }

    fn health(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/health".to_string())
            .execute(self.configuration.borrow())
    }

    fn last_blocks(&self, num: i32) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/last_blocks".to_string())
            .with_query_param("num".to_string(), num.to_string())
            .execute(self.configuration.borrow())
    }

    fn network_connection(&self, addr: &str) -> Box<Future<Item = ::models::InlineResponse2003, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/connection".to_string())
            .with_query_param("addr".to_string(), addr.to_string())
            .execute(self.configuration.borrow())
    }

    fn network_connections(&self, states: &str, direction: &str) -> Box<Future<Item = Vec<::models::InlineResponse2003>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/connections".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("states".to_string(), states.to_string())
            .with_query_param("direction".to_string(), direction.to_string())
            .execute(self.configuration.borrow())
    }

    fn network_connections_disconnect(&self, id: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/network/connection/disconnect".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("id".to_string(), id.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn network_connections_exchange(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/connections/exchange".to_string())
            .execute(self.configuration.borrow())
    }

    fn network_connections_trust(&self, ) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/network/connections/trust".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .execute(self.configuration.borrow())
    }

    fn outputs_get(&self, address: Vec<String>, hash: Vec<String>) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/outputs".to_string())
            .with_query_param("address".to_string(), address.join(",").to_string())
            .with_query_param("hash".to_string(), hash.join(",").to_string())
            .execute(self.configuration.borrow())
    }

    fn outputs_post(&self, address: &str, hash: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/outputs".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("address".to_string(), address.to_string())
            .with_query_param("hash".to_string(), hash.to_string())
            .execute(self.configuration.borrow())
    }

    fn pending_txs(&self, ) -> Box<Future<Item = Vec<::models::InlineResponse2004>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/pendingTxs".to_string())
            .execute(self.configuration.borrow())
    }

    fn resend_unconfirmed_txns(&self, ) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/resendUnconfirmedTxns".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn richlist(&self, include_distribution: bool, n: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/richlist".to_string())
            .with_query_param("include-distribution".to_string(), include_distribution.to_string())
            .with_query_param("n".to_string(), n.to_string())
            .execute(self.configuration.borrow())
    }

    fn transaction(&self, txid: &str, encoded: bool) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/transaction".to_string())
            .with_query_param("txid".to_string(), txid.to_string())
            .with_query_param("encoded".to_string(), encoded.to_string())
            .execute(self.configuration.borrow())
    }

    fn transaction_inject(&self, rawtx: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/transaction/inject".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("rawtx".to_string(), rawtx.to_string())
            .execute(self.configuration.borrow())
    }

    fn transaction_raw(&self, txid: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v2/transaction/raw".to_string())
            .with_query_param("txid".to_string(), txid.to_string())
            .execute(self.configuration.borrow())
    }

    fn transaction_verify(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/transaction/verify".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .execute(self.configuration.borrow())
    }

    fn transactions_get(&self, addrs: &str, confirmed: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/transactions".to_string())
            .with_query_param("addrs".to_string(), addrs.to_string())
            .with_query_param("confirmed".to_string(), confirmed.to_string())
            .execute(self.configuration.borrow())
    }

    fn transactions_post(&self, addrs: &str, confirmed: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/transactions".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("addrs".to_string(), addrs.to_string())
            .with_query_param("confirmed".to_string(), confirmed.to_string())
            .execute(self.configuration.borrow())
    }

    fn uxout(&self, uxid: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/uxout".to_string())
            .with_query_param("uxid".to_string(), uxid.to_string())
            .execute(self.configuration.borrow())
    }

    fn verify_address(&self, address: &str) -> Box<Future<Item = ::models::InlineResponse2007, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/address/verify".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("address".to_string(), address.to_string())
            .execute(self.configuration.borrow())
    }

    fn version(&self, ) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/version".to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet(&self, id: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallet".to_string())
            .with_query_param("id".to_string(), id.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_balance(&self, id: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallet/balance".to_string())
            .with_query_param("id".to_string(), id.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_create(&self, seed: &str, label: &str, scan: i32, encrypt: bool, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/create".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("seed".to_string(), seed.to_string())
            .with_header_param("label".to_string(), label.to_string())
            .with_header_param("scan".to_string(), scan.to_string())
            .with_header_param("encrypt".to_string(), encrypt.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_decrypt(&self, id: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/decrypt".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_encrypt(&self, id: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/encrypt".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_folder(&self, addr: &str) -> Box<Future<Item = ::models::InlineResponse2006, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallets/folderName".to_string())
            .with_query_param("addr".to_string(), addr.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_new_address(&self, id: &str, num: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/newAddress".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("id".to_string(), id.to_string())
            .with_query_param("num".to_string(), num.to_string())
            .with_query_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_new_seed(&self, entropy: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallet/newSeed".to_string())
            .with_query_param("entropy".to_string(), entropy.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_recover(&self, id: &str, seed: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/wallet/recover".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("seed".to_string(), seed.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_seed(&self, id: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/seed".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("id".to_string(), id.to_string())
            .with_query_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_seed_verify(&self, seed: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v2/wallet/seed/verify".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("seed".to_string(), seed.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_spent(&self, id: &str, dst: &str, coins: &str, password: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/spend".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("dst".to_string(), dst.to_string())
            .with_header_param("coins".to_string(), coins.to_string())
            .with_header_param("password".to_string(), password.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_transaction(&self, body: ::models::InlineObject) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/transaction".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_body_param(body)
            .execute(self.configuration.borrow())
    }

    fn wallet_transactions(&self, id: &str) -> Box<Future<Item = Value, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallet/transactions".to_string())
            .with_query_param("id".to_string(), id.to_string())
            .execute(self.configuration.borrow())
    }

    fn wallet_unload(&self, id: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/unload".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_query_param("id".to_string(), id.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn wallet_update(&self, id: &str, label: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/api/v1/wallet/update".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "X-CSRF-TOKEN".to_owned(),
            }))
            .with_header_param("id".to_string(), id.to_string())
            .with_header_param("label".to_string(), label.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn wallets(&self, ) -> Box<Future<Item = Vec<::models::InlineResponse2005>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/api/v1/wallets".to_string())
            .execute(self.configuration.borrow())
    }

}
